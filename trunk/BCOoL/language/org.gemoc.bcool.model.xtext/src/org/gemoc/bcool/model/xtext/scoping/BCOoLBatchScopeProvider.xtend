/*
 * generated by Xtext
 */
package org.gemoc.bcool.model.xtext.scoping

import com.google.inject.Inject
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.ocl.examples.xtext.completeocl.completeoclcs.DefPropertyCS
import org.eclipse.xtext.common.types.JvmIdentifiableElement
import org.eclipse.xtext.naming.QualifiedName
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.xbase.scoping.batch.IFeatureScopeSession
import org.eclipse.xtext.xbase.scoping.batch.XbaseBatchScopeProvider
import org.eclipse.xtext.xbase.typesystem.references.ITypeReferenceOwner
import org.gemoc.bcool.model.bcool.BCoolCompositionRule

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation.html#scoping
 * on how and when to use it 
 *
 */
 
class BCOoLBatchScopeProvider extends XbaseBatchScopeProvider  {
	@Inject extension BCOoLCompositionRuleExtensions

	override IScope getScope(EObject context, EReference reference) {
		if (context instanceof BCoolCompositionRule/*  && "name".equals(reference.name)*/) {
			return (context as BCoolCompositionRule).getScope(super.getScope(context, reference))
		} else
			return super.getScope(context, reference)
	}
	
	
	override newSession(Resource context) {
		var IFeatureScopeSession result = super.newSession(context)
			for (Resource r : context.getResourceSet().resources){
				for (EObject eo :r.contents){
					if (eo instanceof DefPropertyCS){
						result.addLocalElement(QualifiedName.create(eo.name), eo as JvmIdentifiableElement, context as ITypeReferenceOwner)
					} 
					//state.addLocalToCurrentScope(eo as JvmIdentifiableElement)		
				}
			}	
		return result
	}
	
	
//	
//	override computeTypes(XExpression expression, ITypeComputationState state) {
//		switch (expression) {
//			XBlockExpression: expression._computeTypes(state)
//		default: super.computeTypes(expression, state)
//}
//}
//	
//	override void _computeTypes(XBlockExpression b, ITypeComputationState typeState) {
//		var state = typeState
//		if (b.eContainer instanceof CoordinationRule){
//			val rule = b.eContainer as CoordinationRule
//			
//			for (Resource r : rule.eResource().getResourceSet().resources){
//				for (EObject eo :r.contents){
//					state.addLocalToCurrentScope(eo as JvmIdentifiableElement)		
//				}
//			}
//		}
//		
//	}
//
//protected def void addVariableDeclarationsToScope(XExpression e, ITypeComputationState state) {
//	switch (e) {
//	//XVariableDeclaration : addLocalToCurrentScope(e, state)
//			CoordinationRule : {
//				for (Resource r : e.eResource.resourceSet.resources) {
//					for (exp : r.contents){
//					if (exp instanceof XVariableDeclaration) {
//						addLocalToCurrentScope(exp, state);
//					}
//					}
//				}
//			}
//		}
//	}

//override IScope getScope(EObject context, EReference reference) {
//			if (context == null || context.eResource() == null || context.eResource().getResourceSet() == null) {
//				return IScope.NULLSCOPE;
//			}
//			if (context instanceof XBlockExpression){
//				throw new NoClassDefFoundError();
//			}
//			var IScope scope = super.getScope(context,reference)
//			for (Resource r : context.eResource().getResourceSet().resources){
//				scope = Scopes.scopeFor(r.contents, scope);
//			}
//
//			return scope;
//		}
//				
}
